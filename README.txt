

# --------------------------------------------
#   Name: Hadi Rohani
# --------------------------------------------

- Three drivers are used to evaluate the address space before and after a Process
    is executed.
    mem_1 : For this, a large area of memory is allocated and initialized to see
    the effect on memory regions.

    mem_2: A modified Fibonacci recursion function is used and it is called to
    return the sum of value of the function for three numbers before number "n".

    mem_3: Using mmap() considering a particular memory address we assign the
    memory for mapping a file, however, using MAP_ANONYMOUS flag and assigning
    PROT_READ | PROT_WRITE the particular memory regions are assigned to be RW.

- for mem_1:
    4 MB of memory is allocated and using calloc() it is initialized to zero.
    So, we have read/write access to this corresponding memory location. When
    mem_1.c is compiled and executed, The allocated memory regions before and 
    after the memory assignment are compared. The number of memory regions
    before and after the memory allocation (i.e calloc()) is 18 and 20, respectively.
    The region 0x09c16000 - 0x09c36fff was in NO, but after calling calloc() their
    access has changed to RW.

- for mem_2:
    The access to addresses 0x09f65000 - 0x09f85fff is changed from NO to RW that
    splits the memregion 0x0804b000 - 0xf7d77fff that has a NO access to two slices.
    Basically, fibo_modified(30) iteratively calls the function for 30 times and each
    time it is called for 3 additions. Therefore, this is a very iterative function.
    Note that if larger values are selected the allocated memory may not suffice and
    it would take longer to run.

- for mem_3:
    Memory file mapping is deployed here and mmap() is used. To avoid using a file
    as it was not part of the deliverables of the assignment, the flag MAP_ANONYMOUS
    is considered. The allocated memory is set to RW with the corresponding size 
    (here the size is 4kB) and that is reflected in the address space of memory.
    0x0895b000 - 0x0897bfff is allocated for the mmap().

In all three drivers, the number of memory regions are changed (from 18 to 20) to
accommodate for the particular process to run.

Running Instructions:
    Makefile is used to comfortably compile and run the files.
    All that is needed is to type $ make
    When the executable files are generated (mem_1 and mem_2 and mem_3) then they
    can be run using ./mem_x.

    To remove output files and executables, simply type and run $ make clean

Observations:
    When attempting to evaluate get_mem_layout function using pmap, the results generated
    by pmap shows a particular memory region as rw while this is not reflected in the 
    memregion generated by get_mem_layout. As per the email with the Instructor, using
    pmap is not an absolute tool to verify process address space.

    Another important observation is that when trying to mmap((void *)0x0804f000,...),
    this is not reflected in the generated output of address space representations.
    The kernel gives a specific address for the memory map file address. The memory
    allocation is readily noticable, but this is not accurately reflected.

    For mem_1, since the recursive function has a lot of iterations, the allocated memory
    is massive and also noticeable when looking at the associated memregion.
    


